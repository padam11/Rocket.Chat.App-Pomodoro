{"version":3,"sources":["src/server/managers/AppSchedulerManager.ts"],"names":[],"mappings":"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","file":"AppSchedulerManager.js","sourcesContent":["import { AppMethod } from '../../definition/metadata';\nimport {\n    IJobContext,\n    IOnetimeSchedule,\n    IProcessor,\n    IRecurringSchedule,\n} from '../../definition/scheduler';\nimport { AppManager } from '../AppManager';\nimport { IInternalSchedulerBridge } from '../bridges/IInternalSchedulerBridge';\nimport { SchedulerBridge } from '../bridges/SchedulerBridge';\nimport { AppAccessorManager } from './';\n\nfunction createProcessorId(jobId: string, appId: string): string {\n    return jobId.includes(`_${appId}`) ? jobId : `${ jobId }_${ appId }`;\n}\n\nexport class AppSchedulerManager {\n    private readonly bridge: SchedulerBridge;\n    private readonly accessors: AppAccessorManager;\n\n    private registeredProcessors: Map<string, {[processorId: string]: IProcessor}>;\n\n    constructor(private readonly manager: AppManager) {\n        this.bridge = this.manager.getBridges().getSchedulerBridge();\n        this.accessors = this.manager.getAccessorManager();\n        this.registeredProcessors = new Map();\n    }\n\n    public async registerProcessors(processors: Array<IProcessor> = [], appId: string): Promise<void | Array<string>> {\n        if (!this.registeredProcessors.get(appId)) {\n            this.registeredProcessors.set(appId, {});\n        }\n\n        return this.bridge.doRegisterProcessors(processors.map((processor) => {\n            const processorId = createProcessorId(processor.id, appId);\n\n            this.registeredProcessors.get(appId)[processorId] = processor;\n\n            return {\n                id: processorId,\n                processor: this.wrapProcessor(appId, processorId).bind(this),\n                startupSetting: processor.startupSetting,\n            };\n        }),  appId);\n    }\n\n    public wrapProcessor(appId: string, processorId: string): IProcessor['processor'] {\n        return async (jobContext: IJobContext) => {\n            const processor = this.registeredProcessors.get(appId)[processorId];\n\n            if (!processor) {\n                throw new Error(`Processor ${processorId} not available`);\n            }\n\n            const app = this.manager.getOneById(appId);\n\n            const context = app.makeContext({\n                processor,\n                args: [\n                    jobContext,\n                    this.accessors.getReader(appId),\n                    this.accessors.getModifier(appId),\n                    this.accessors.getHttp(appId),\n                    this.accessors.getPersistence(appId),\n                ],\n            });\n\n            const logger = app.setupLogger(AppMethod._JOB_PROCESSOR);\n            logger.debug(`Job processor ${processor.id} is being executed...`);\n\n            try {\n                const codeToRun = `processor.processor.apply(null, args)`;\n                await app.runInContext(codeToRun, context);\n                logger.debug(`Job processor ${processor.id} was sucessfully executed`);\n            } catch (e) {\n                logger.error(e);\n                logger.debug(`Job processor ${processor.id} was unsuccessful`);\n\n                throw e;\n            } finally {\n                await this.manager.getLogStorage().storeEntries(appId, logger);\n            }\n        };\n    }\n\n    public async scheduleOnce(job: IOnetimeSchedule, appId: string): Promise<void | string> {\n        return this.bridge.doScheduleOnce({ ...job, id: createProcessorId(job.id, appId) }, appId);\n    }\n\n    public async scheduleRecurring(job: IRecurringSchedule, appId: string): Promise<void | string> {\n        return this.bridge.doScheduleRecurring({ ...job, id: createProcessorId(job.id, appId) }, appId);\n    }\n\n    public async cancelJob(jobId: string, appId: string): Promise<void> {\n        this.bridge.doCancelJob(createProcessorId(jobId, appId), appId);\n    }\n\n    public async cancelAllJobs(appId: string): Promise<void> {\n        this.bridge.doCancelAllJobs(appId);\n    }\n\n    public async cleanUp(appId: string): Promise<void> {\n        (this.bridge as IInternalSchedulerBridge & SchedulerBridge).cancelAllJobs(appId);\n    }\n}\n"]}